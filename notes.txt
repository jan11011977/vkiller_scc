TODO:
- Implement sound change to "out of time" as suggested by Jelle
- Do a final play


turbofix patch (19 dec 2017)
----------------------------
I switched to base my patch on the 'turbofix' patch,
because this fixes the glitchy sprites at the top and enables R800
however this is now causing random lockups and music corruption in stage clear
most likely because the interrupt handling is slightly different now

sidenote: the turbofix patch causes graphics corruption on the ending
titles (when you complete the game)


kick drum fix notes
-------------------
The Konami PSG kick and snare rely on a click noise generated by a PSG envelope.
The snare consists of a click, followed by noise. The bass drum is just a click
(a slightly longer one). The problem is that if the oscillator is in the 'off'
state at the start of the envelope, you don't hear the initial 'click'.
This means that the sound of the kick/snare is not consistent.
The fix is to set the oscillator frequency to '0', which makes it output
a solid '1'. This way the sound of the click is consistent.

SCC player reverse engineering notes:

229c <- contains bit of PSG register that need to be set
229d/e/f <- contains the values of PSG registers 11, 12, 13


6b51 <- where the jump table is used
6b5d <- jump table of addresses for drum set routines???
6bed <- kick drum routine


PSG frequency eg. register 0, 1 values are stored in IX+a/b, e.g. 200A, 200B


66EE <- frequency is set here
if I NOP this routine out and force the frequency to 0000 then the kick/snare are consistent
but we lose the tonal part of some of the drums

the frequency that 66EE sets comes from  IX+10/11
(these are basically copied from 10/11 -> a/b)

6509 <- 10/11 frequency is set here
  for the kick drum, HL = 7485?
  kick drum settings are at 7484:
  7484 = 0A envelope frequency
  7485 = 94 flags + frequency (high bits)
  7486 = 50 frequency low bits
 


music corruption when changing songs
------------------------------------
when changing songs, the music must first be stopped using command 00
(command 83 on nemesis 3 player). Without this, the music_start code can get
interrupted by the music player that runs on the interrupt. this can then cause
the first few notes of the new song to have the wrong frequency
<- not relevant anymore because we disable interrupts throughout
   the 'start music' function???


Game Master detection
---------------------
The code for this is at 5c92 - 5ce8.
It loops over all subslots, and checks address 7FFA - 7FFF (last 6 bytes).
It should have data: 00 30 31 13 35 aa

If it does then it sets 0e600h to 0xff which indicates that the Game Master was detected.
If it was not detected, it sets 0e600h to 0x00


MEMORY (RAM) USAGE
------------------
  while we are running the music player, we swap out the BIOS for RAM and use that
  for the ram used by the SCC music player.
  this is because all the normal RAM is used by vkiller itself
  need to patch all calls to BIOS 093h (write PSG) to use our own function:

              di
              out     (0A0h), a  ; set register
              push    af
              ld      a, e
              ei
              out     (0A1h), a  ; write value
              pop     af

  this way we can use the 0000-3fff RAM without having to copy the bios
  it also allows us to prevent interrupts from being enabled when writing to the PSG


fixing PSG interference between nemesis3 and vkiller player
------------------------------------------------------------
there is a single PSG register 7 which sets noise/tone channels on/off
the two players are overwriting eachothers information here
vkiller stores the state in C097 
nemesis3 stores it in e298
I changed the nemesis3 PSG write function so that when it writes to register 7, it
only writes the bits for one channel and gets the other bits from c097
it also updates its own bits in c097
this stop the grinding interference for the PSG drums
the vkiller PSG SFX still have some interference



compiling music into nemesis3.kss
---------------------------------
nemesis3.kss layout is as follows:

0050 - a
2050 - 9
4050 - 19
6050 - b
8050 - c
a050 - d

so to compile the data we need to skip a gap between 2050 and 6050
(no idea why the kss file has bank 9 and 19 in there. they are not needed)

nemesis 3 drums
---------------
c - ch
c# - oh
d - rim
d# - snare hit
e - snare slide
f - tom hi
f# - tom mid
g - tom mid
g# - tom lo
a - bd

instruments

i23 = meaty sharp saw
i27 = ring mod lead
i32 = similar meaty sharp saw
i1 = i14 = i19 = warm and meaty saw
i29 = church organ
i12 = sine wave
i7 = higher sine wave
i9 = organ
i3 = nice square
i6 = soft square
i10 = double soft organ
i11 = saw bell lead - very often used as the lead sound


i21 -> i88  DULL -> BRIGHT

commands

eaxx = start level e.g. @cmd(ea0a)
dbxx = sustain level e.g. @cmd(db03) (must be lower than start level)
ebxxxx = attack time + something else
ddxxxx = envelope with fake echo e.g. @cmd(dd2732)
f2xx = delay before tremolo starts e.g. @cmd(f209)
f1xy = tremelo control (x=speed, y=amount) e.g. @cmd(f153)


DECOMPILING
-----------
TODO:
- write out song tables
  need to invent some kind of syntax for this

  @song(13,
        give_my_heart_to_you_#0,
        give_my_heart_to_you_#1,
        give_my_heart_to_you_#2,
        give_my_heart_to_you_#3,
        give_my_heart_to_you_#4,
        give_my_heart_to_you_#5,
        give_my_heart_to_you_#6,
        give_my_heart_to_you_#7)



OLD NOTES
---------

4) replace a PSG player with SCC player
   allows us to put SCC music in Usas or Galious
   is this doable? not sure
   - would need to expand the cartridge size
   - need to replace the music player code
     if there are any game-related hooks/callbacks they would need to be fixed up
   - ram location for channel data may need to be relocated/freed
   - sound effects would need to be played by the old player
     it would have control of one PSG channel
   - what is the interface for starting a new song?

   vampire killer:
   - channel data @ 0xc01c, 0xc030, 0xc044
   - music player update @ 0x8964
   - music data around 0xa48a
   music player is similar in design, although the implementation is totally different
   0-0xc0    = note on
   0xc0-0xd0 = note off
   0xe?      = special commands
   0xea      = goto (I think)
   0xf?      = PSG drums(?) not sure

   command execution function @ 0x8aca


  todo:
  - port vampire killer to use an scc mapper
    use an openmsx tsc script to detect mapper
    accesses and replace them
  - figure out the "play song" function
    use openmsx data breakpoints
  - disable two of the original player's psg channels
  - put an scc player in extra mapper memory and call
    it on interrupt
    when changing songs, change songs on the scc player

    not sure how easy it will be to disentangle the player
    relocation the player would be hard, eg wavetable offsets, jumps, lookup tables
    probably not necessary though
    all konami players should be in 4000-c000 range



proof of concept:

0) turn vanpire killer into a scc rom(?)
1) append nemesis3 to vampire killer rom
2) add a call to nemesis3 music update routine
3) add a call to nemesis3 music start routine

what I need to know:
- nemesis3 new song start function address -> 6003
  song number in A register
  special meanings: a = 0x83, 0x84, 0x85, etc. (fade out etc.)
- nemesis3 player update function address -> 6006
  mapper banks:
  (!)di
  A -> 7000
  B -> 9000
  C -> b000
  NOTE: Nemesis 3 stores original mapper banks in f0f1, f0f2, f0f3
  so restoring the original banks is done like...
  di
  ld a,(0xf0f1)
  ld (0x7000),a
  ld a,(0xf0f2)
  ld (0x9000),a
  ld a,(0xf0f3)
  ld (0xb000),a
  ei


- need some space in vampire killer rom to insert assembly to:
  - change banks to nemesis 3
  - call nemesis 3 update routine
  vkiller init routine:   50c0
  vkiller update routine: 8964
  
  vkiller music address: around 94a8-a5f9
  a3a8 - start of some unused song or something

what needs to happen:
at 0x50c0 and 0x8964, put calls
- write some assembler which flips mapper bank 1
  and then calls a function on that mapper bank
  then once it returns it should restore the original banks
- insrt code at 0x50c0 and 0x8964 that uses that function
  to call code on the music player
- music player 'start song' could initially just always
  play the same song

alternatively... if I could find some space in 0x4000-0x6000
then it would make things a bit easier

*or* I could ldir the code to RAM and then run it from there


steps:

1) copy some instructions from 0x50a5 and 0x8964
   into new assembly @ 0xa3a8

   0x50a5:
     push hl
     push de
     push bc
     push af

    0x8964:
      ld a,(c097)
      ld e,a

   then call that code from the original code

   test the rom - it should still work

2) write a new empty bank targeted at 0x4000
   put a RET in there

3) write code to switch the new bank in and call
   the function
   it should hit the RET and return

   test the rom - it should still work

4) switch banks to 6000, 8000, a000
   then switch them back again

   test the rom - it should still work

5) add calls to nemesis 3 music functions

-----------------------------------------------------

FINDING FREE MEMORY

NEW PLAN:

put shim code in 06000h bank
put code in there which:
- maps the 08000h-0bfffh data bank into 0c000h-0ffffh
- map RAM into 08000h-0bfffh and copy the data in there
some of the space at the end of 0bfffh can then be used
for the channel data

how do we find space for our extra code?
- decompile the songs
- recompile the songs at a higher address

7506 - song addresses
75ac - tracks start address

potentially allows us to free 75ac-7fff

-----------------------------------------------------

*OR*

di
ld a,0xf
ld (0x5000), a
call 0x4000
xor a
ld (0x5000), a
ei

-----------------------------------------------

how do i tie all this assembler together?

I guess using labels and setting target addresses
not rocket science

but then i have to copy the output somewhere


methods:

- copy to ram and run
  + only one piece of assembler to write
  - costs valuable ram

---------------------------------------------

NEW PLAN

hook update function at 0x4030
overwrite the page-switching code
jump to my own code, which is embedded in the music player

for the music-start code we will need to insert
page-switching code in there as well
means patching over more code, but that's ok

>> need to find space to put my code in the nemesis 3
music player

NOTE: 0x4000 code also needs to switch the banks back
      our code can't do it because it will switch
      itself out

free space @ 0xbe28



problem with patching the interrupt:

there is not enough space at 0x4030 to:
- swap to my mapper bank
- call my function
- swap to vkiller's mapper bank
- call its function


I can't call vkiller's function directly from mine
either because it's in the same bank so my code
gets swapped out


solutions:
- find some space in 0x4000-0x6000 block
- copy the bank-swapping code into RAM
  how do I get it in RAM in the first place?
- put my code in 0x6000 in the nemesis3 player
  that way it can call the vkiller update function
  without getting swapped out
  ... but it would still need to swap itself out
  in case the vkiller update function calls code
  in that mapper block


could potentially save some space at
0x5351, 0x537d, 0x53b9

these routines are the same except for different A reg
could make a shared function that takes an A reg
IDA is saying that there are calls into the middle
of these functions but that's false

in the free space we could then put the code:

        ld      a, 18
        ld      (0b000h), a
        call    music_update
        ld      a, (0f0f3h)
        ld      (0b000h), a
        <patched instruction>
        <patched instruction>
        ret

we could then insert a
<call xxx>
and we would only need to copy over three instruction bytes

POTENTIAL SOLUTION:

in 0x53bf insert a JR to 0x5383
0x18 0xc2

gives me 16 bytes of free space

what needs to go in there?

        ld      a, 18
        ld      (0b000h), a
        call    music_update
        ld      (hl), a
        ret

10 bytes. fits in the smaller gap

we can then overwrite the ld(8000),a instruction
with a call to this shim function
music_update would need to do
    ld a, 14
    ld  hl, 0b000h
    before returning

still need to solve the music_start patching

53ad JR to 539b

what needs to go in there?

        push hl
        push de
        push bc
        di
        ld      a, 18 
        ld      (0b000h), a
        call    music_update
        ld      (hl),a
        ei
        ret

15 instructions. fits in the bigger gap

music init function would need to do:
        ld a,(f0f3)
        ld hl, b000h
        before returning

we could overwrite the first three push instructions
with a call
